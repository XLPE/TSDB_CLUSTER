/*
 * file: zklua.c
 * auth: chenjainfei@daoke.me
 * date: May 27, 2014
 * desc: not thread safe. sync with zk.h.
 */

#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
#include <string.h>
#include <stdint.h>
#include <stdio.h>
#include <assert.h>

#include "zookeeper_log.h"
#include "zookeeper.h"

#define KEY_SIZE 8192
#define HOST_LEN 64
#define DATA_SET_SIZE 2
#define SERVICE_LEN 8
#define ERR_MSG_LEN 64


typedef struct _cxt {
    zhandle_t *zkhandle;
    char service[SERVICE_LEN];
    struct String_vector cache[KEY_SIZE];
    uint8_t synced[KEY_SIZE];
    uint8_t stop;
} watch_cxt;

/*
 * zk-server watcher.
 */
static void zk_watcher(zhandle_t *zh, int type, int state, const char *path, void *watcherCtx)
{
    if (type == ZOO_SESSION_EVENT) {
        if (state == ZOO_CONNECTED_STATE) {
            printf("[luazk][zk_watcher]:connected to zookeeper service successfully!\n");
        } else if (state == ZOO_EXPIRED_SESSION_STATE) {
            printf("[luazk][zk_watcher]:Zookeeper session expired!\n");

            // FIXME: need double check.
            exit(1);
        }
    }
}

/*
 * get key from path
 */
static int get_key_from_path(const char *path, int level)
{
    /* path format: /keys/GPS/0000 */
    const char *tmp = path;
    int i;
    for (i=0; i<level; ++i) {
        tmp = strchr(tmp, '/');
        ++ tmp;
    }

    return atoi(tmp);
}

/*
 * zk-node watcher.
 */
static void znode_watcher(zhandle_t *zh, int type, int state, const char *path, void *watcherCtx)
{
    printf("[luazk][znode_watcher]:type: %d, state: %d, path: %s\n", type, state, path);

    if (state == ZOO_CONNECTED_STATE) {
        /* we watched znode is changed. */
        if (type == ZOO_CHILD_EVENT) {
            /* initial the cache. */
            watch_cxt *wc = (watch_cxt *) watcherCtx;
            if (wc->stop) {
                return;
            }

            /* key format: /keys/URL/0001 */
            int key = get_key_from_path(path, 3);
            printf("[luazk][znode_watcher]:watched. key: %d\n", key);

            // memset(wc->synced, 0, KEY_SIZE * sizeof(uint8_t));
            assert(key >=0 && key < KEY_SIZE);
            wc->synced[key] = 0;
        }
    }

    return;
}

/*
 * open a zookeeper handle.
 * input:       nil
 * output:      1. if succeed return zkhandle(integer), else return nil.
 *              2. if succeed return nil, else return error msg.
 */
static int open_zkhandler(lua_State *L)
{
    char errmsg[ERR_MSG_LEN] = { 0 };

    /* parse input parameters. */
    const char *zkhost = lua_tostring(L, 1);

    /* set zk log level. */
    zoo_set_debug_level(ZOO_LOG_LEVEL_ERROR);

    /* open a zookeeper. */
    zhandle_t * zkhandle = zookeeper_init(zkhost, zk_watcher, 30000, 0, "Hello zookeeper.", 0);
    if (zkhandle == NULL ) {
        sprintf(errmsg, "[luazk error]:zookeeper_init failed.");
        lua_pushnil(L);
        lua_pushstring(L, errmsg);
        return 2;
    }

    /* returns. */
    lua_pushinteger(L, (long)zkhandle);
    lua_pushnil(L);
    return 2;
}

/*
 * close the zookeeper handle.
 * input:       1. zkhandle(integer)
 * output:      1. return true.
 */
static int close_zkhandle(lua_State *L)
{
    zhandle_t *zkhandle = (zhandle_t *) lua_tointeger(L, 1);
    zookeeper_close(zkhandle);

    lua_pushboolean(L, 1);
    return 1;
}

/*
 * register a host-cache for specified service.
 * input:       1. zkhandle(integer)
 *              2. service(string)
 * output:      1. if succeed return cache-handle(integer), else return nil.
 *              2. if succeed return nil, else return error msg(string).
 */
static int reg_host_cache(lua_State *L)
{
    char errmsg[ERR_MSG_LEN] = { 0 };

    /* parse input parameters. */
    zhandle_t *zkhandle = (zhandle_t *) lua_tointeger(L, 1);
    const char *service = lua_tostring(L, 2);
    if (zkhandle == NULL || service == NULL ) {
        sprintf(errmsg, "[luazk error]:reg_host_cache input error.");
        lua_pushnil(L);
        lua_pushstring(L, errmsg);
        return 2;
    }

    /* initial watcher context. */
    char node[64] = { 0 };
    watch_cxt *wc = (watch_cxt *) malloc(sizeof(watch_cxt));
    memset(wc, 0, sizeof(watch_cxt));
    wc->zkhandle = zkhandle;
    assert(strlen(service) < SERVICE_LEN);
    strcpy(wc->service, service);

    /* returns. */
    lua_pushinteger(L, (long)wc);
    lua_pushnil(L);
    return 2;
}

/*
 * unregister the host-cache for specified service.
 * input:       1. cache-handle(integer)
 * output:      1. if succeed return true, else return nil.
 *              2. if succeed return nil, else return error msg(string).
 */
static int unreg_host_cache(lua_State *L)
{
    char errmsg[ERR_MSG_LEN] = { 0 };

    /* parse input parameters. */
    watch_cxt *wc = (watch_cxt *) lua_tointeger(L, 1);
    if (wc == NULL ) {
        sprintf(errmsg, "[luazk error]:unreg_host_cache input error.");
        lua_pushnil(L);
        lua_pushstring(L, errmsg);
        return 2;
    }

    /* set watcher context. */
    wc->stop = 1;

    /* returns. */
    lua_pushboolean(L, 1);
    return 1;
}

/*
 * get write hosts.
 * input:   1. cache-handle(integer)
 *          2. key(integer)
 * output:  1. if succeed return host(table), else return nil
 *          2. if succeed return nil, else return error message(string).
 */
static int get_write_hosts(lua_State *L)
{
    char errmsg[ERR_MSG_LEN] = { 0 };

    /* parse input parameters. */
    watch_cxt *wc = (watch_cxt *) lua_tointeger(L, 1);
    int key = lua_tointeger(L, 2);
    if (wc == NULL || key < 0 || key >= KEY_SIZE) {
        sprintf(errmsg, "[luazk error]:get_write_hosts input error.");
        lua_pushnil(L);
        lua_pushstring(L, errmsg);
        return 2;
    }

    /* if not hit the cache, then access zk-server. */
    if (wc->synced[key] == 0) {
        char node[512] = { 0 };
        sprintf(node, "/keys/%s/%04d", wc->service, key);
        struct String_vector sv;
        int ret = zoo_wget_children(wc->zkhandle, node, znode_watcher, wc, &(wc->cache[key]));
        if (ZOK != ret) {
            sprintf(errmsg, "[luazk error]:get_write_hosts zoo_get_children error, errno: %d", ret);
            lua_pushnil(L);
            lua_pushstring(L, errmsg);
            return 2;
        }
        wc->synced[key] = 1;
    }

    /* returns. */
    lua_newtable(L);
    int32_t i;
    for (i = 0; i < wc->cache[key].count; i++) {
        if (strstr(wc->cache[key].data[i], "RW:")) {
            lua_pushstring(L, wc->cache[key].data[i]);
            lua_rawseti(L, -2, i + 1);
        }
    }
    return 1;
}

/*
 * get write hosts without cache.
 *
 * input :  zkhost
 *          service
 *          key
 * output:  if succeed return write hosts(table), else return nil
 *          if succeed return nil, else return error message(string).
 */
static int get_write_hosts_nocache(lua_State *L)
{
    const char *zkhost = lua_tostring(L, 1);
    const char *service = lua_tostring(L, 2);
    int key = lua_tointeger(L, 3);

    /* set zk log level. */
    zoo_set_debug_level(ZOO_LOG_LEVEL_ERROR);

    /* create a zk handle. */
    char errmsg[64] = {0};
    zhandle_t *zkhandle = NULL;
    int zktimeout = 30000;
    zkhandle = zookeeper_init(zkhost, NULL, zktimeout, 0, "luazk: get write node.", 0);
    if(zkhandle == NULL) {
        lua_pushnil(L);
        lua_pushstring(L, "[luazk error]:zk init error.");
        return 2;
    }

    /* get host. */
    struct String_vector sv;
    char node[512] = {0};
    sprintf(node, "/keys/%s/%04d", service, key);
    int ret = zoo_get_children(zkhandle, node, 0, &sv);
    if(ZOK != ret) {
        sprintf(errmsg, "[luazk error]:zoo_get_children error, errno: %d", ret);
        lua_pushnil(L);
        lua_pushstring(L, errmsg);
        return 2;
    }

    /* close zk handle.*/
    zookeeper_close(zkhandle);

    /* deal result. */
    int i;
    lua_newtable(L);
    for(i=0; i<sv.count; i++) {
        if(strstr(sv.data[i], "RW:")) {
            lua_pushstring(L, sv.data[i]);
            lua_rawseti(L, -2, i+1);
        }
    }

    return 1;
}


static const luaL_Reg lib[] = {
    { "open_zkhandler", open_zkhandler },
    { "close_zkhandle", close_zkhandle },
    { "reg_host_cache", reg_host_cache },
    { "unreg_host_cache", unreg_host_cache },
    { "get_write_hosts", get_write_hosts },
    { "get_write_hosts_nocache", get_write_hosts_nocache },
    { NULL,NULL }
};

int luaopen_libluazk(lua_State *L)
{
    luaL_register(L, "libluazk", lib);
    return 0;
}
